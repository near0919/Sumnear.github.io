{"pages":[{"title":"关于我","text":"在代码生涯中找到我的ONE PIECE——成为一流的程序设计师","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"git学习02rebase和merge","text":"变基（rebase）当执行变基时，你的目标是确保功能分支从发布分支获取最新代码。变基命令尝试逐个添加每个提交，并检查冲突。 git merge是用来合并两个分支的。 变基和合并（merge）在 Git 中都很有用。两种并无优劣之分。 在合并的情况下，你将有个合并提交。在变基的情况下，不会像合并提交那样有额外的提交。 一种最佳的实践是一分为二。使用远端仓库中的最新代码更新本地仓库时，请使用变基。在处理拉取请求，以将功能分支和发布分支或主分支合并时，请使用合并。 使用变基会更改历史提交记录（使其更整洁）。但话虽如此，改变历史提交存在风险。因此，请确保永远不要对远程存储仓库的代码使用变基。始终仅对本地仓库代码使用变基，来更改历史提交记录。 如果对远端仓库进行变基，会制造许多混乱，因为其他开发人员无法识别新的历史记录。 此外，如果在远端仓库上完成变基，则当其他开发人员尝试从远端仓库中拉取最新代码时，就可能会出问题。所以，我再重申一遍，变基总是仅在本地仓库中进行。 远程origin和本地mywork都指向C2版本 远程origin新提交C3、C4版本；本地mywork新提交C5、C6版本 本地mywork merge origin 本地mywork rebase origin 本地mywork rebase origin 查看log的样子 merger和rebase使用Git log的样子 当我们使用Git log来参看commit时，其commit的顺序也有所不同。 假设C3提交于9:00AM,C5提交于10:00AM,C4提交于11:00AM，C6提交于12:00AM, 对于使用git merge来合并所看到的commit的顺序（从新到旧）是：C7 ,C6,C4,C5,C3,C2,C1 对于使用git rebase来合并所看到的commit的顺序（从新到旧）是：C7 ,C6‘,C5’,C4,C3,C2,C1 因为C6’提交只是C6提交的克隆，C5’提交只是C5提交的克隆， 从用户的角度看使用git rebase来合并后所看到的commit的顺序（从新到旧）是：C7 ,C6,C5,C4,C3,C2,C1 解决冲突 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用”git-add”命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: $ git rebase –continue 这样git会继续应用(apply)余下的补丁。 在任何时候，你可以用–abort参数来终止rebase的行动，并且”mywork” 分支会回到rebase开始前的状态。 $ git rebase –abort 出处： https://blog.csdn.net/wh_19910525/article/details/7554489","path":"2018/12/24/git学习02rebase和merge/"},{"title":"git学习01常用命令","text":"$ git config –global credential.helper store 记住密码$ git config –global user.name “Your Name” 设置全局用户名$ git config –global user.email “near0919@foxmail.com“ 设置全局邮箱$ git init 在当前目录下初始化本地git仓库$ git add readme.txt 把Working Directory（工作区）的内容 提交到 Index缓存区中$ git commit -m “wrote a readme file” 把Index缓存区中的内容提交到 Repository版本库 -m 提交说明$ git status 查看当前仓库的状态，$ git diff readme.txt 查看difference$ git diff HEAD – readme.txt 查看工作区和版本库里面最新版本的区别$ git log 查看从近到远的提交日志 –pretty=oneline首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。$ git reset –hard HEAD^$ git reset –hard 3628164$ git reflog 用来记录你的每一次命令 $ git checkout – readme.txt git checkout – file可以丢弃工作区的修改$ git reset HEAD readme.txt 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。$ git rm test.txt 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit$ ssh-keygen -t rsa -C “youremail@example.com“ 创建SSH key $ git remote rm origin 删除已有的远程库$ git remote add origin git@gitee.com:SumTeam/gitDemo.git 本地关联远程库 $ git pull origin master fetch+meger fatal: refusing to merge unrelated histories $ git pull origin master –allow-unrelated-histories （拒绝合并不相关的历史） 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。 查阅了一下资料，发现可以在pull命令后紧接着使用–allow-unrelated-history选项来解决问题（该选项可以合并两个独立启动仓库的历史）。 $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 $ git clone git@github.com:michaelliao/gitskills.git 克隆一个本地库 $ git checkout -b dev = $ git branch dev + $ git checkout dev -b参数表示创建并切换 $ git branch 查看当前分支 列出所有分支，当前分支前面会标一个*号。 $ git merge dev 合并指定分支到当前分支 $ git branch -d dev 删除dev分支 $ git log –graph –pretty=oneline –abbrev-commit 用git log –graph命令可以看到分支合并图。 59bc1cb conflict fixed|\\| * 75a857c AND simple | 400b400 &amp; simple|/ fec145a branch test $ git merge –no-ff -m “merge with no-ff” dev 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 $ git stash 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 $ git stash list 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了 $ git branch -d feature-vulcan 删除分支 $ git branch -D feature-vulcan 强行删除分支 $ git remote -v 查看远程库的信息 $ git push origin master 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 $ git pull = fetch + merge $ git branch –set-upstream branch-name origin/branch-name 原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接 $ git tag v1.0 打一个新标签 $ git tag 查看所有标签 找到历史提交的commit id，然后打上 标签 $ git log –pretty=oneline –abbrev-commit $ git tag v0.9 6224937 $ git show v0.9 查看v0.9标签详情 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m “version 0.1 released” 3628164 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m “signed version 0.2 released” fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错： gpg: signing failed: secret key not available error: gpg failed to sign the data error: unable to sign the tag 如果报错，请参考GnuPG帮助文档配置Key。 $ git tag -d v0.1 删除标签 $ git push origin v1.0 推送某个标签到远程 $ git push origin –tags 一次性推送全部尚未推送到远程的本地标签 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag ‘v0.9’ (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To git@github.com:michaelliao/learngit.git [deleted] v0.9","path":"2018/12/24/git学习01常用命令/"},{"title":"设计模式06开闭原则","text":"开闭原则 Open Close PrincipleSoftware entities like classes,modules and functions should be open for exension but closed for modifications.一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。 keep the bar green to keep the code clean 1、开闭原则对测试的影响业务逻辑要保证测试到;边界条件要测试到;异常要测试到 2、开闭原则可以提高复用性 3、开闭原则可以提高可维护性 4、面向对象开发的要求万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就要需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。 1、抽象约束抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。 2、元数据metadata控制模块行为达到极致的就是 spring的 控制反转 Inversion of Control 。通过扩展一个子类，修改配置文件，完成了业务变化。 3、制定项目章程 4、封装变化对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protexted variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，23个设计模式都是从各个不同的角度对变化进行封装的。 开闭原则只是精神口号，实现拥抱变化的方法非常多，并不局限于这6大设计原则，但是遵循这6大设计原则基本上可以应对大多数变化。开闭原则是一个终极目标，朝着这个方向努力，可以非常显著的改善一个系统的架构，真正做到“拥抱变化”。","path":"2018/12/20/设计模式06开闭原则/"},{"title":"设计模式05迪米特法则","text":"迪米特法则 Law of Demeter , LoD一个对象应该对其他对象有最少的了解。一个类应该对自己需要耦合或者调用的类知道的最少。1、只和朋友交流 Only talk to your immedate friends参数能少传递就少传递。2、朋友间也是有距离的暴露的方法尽量少，把风险控制在自己的类里。3、是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。4、谨慎使用Serializable在远程方法调用的情况下（RMI），服务端修改了VO的属性，调用方没有对此更新，就会序列化失败。 迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。同时会导致复杂性提高，维护难度增加。在考虑这个法则的时候需要反复权衡，既要让结构清晰，又要做到高内聚低耦合。解耦是有限度的，计算机最小单元二进制的0和1才是完全解耦，不要为了套用原则而做项目。反复度量，不遵循是不对的，严格执行就是“过犹不及”。","path":"2018/12/20/设计模式05迪米特法则/"},{"title":"IDEA_keymap","text":"教程地址： https://github.com/judasn/IntelliJ-IDEA-Tutorial/ 作者主页： http://www.YouMeek.com 其他不多说，速查表自用， 每日一练熟能生巧。 Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + N 根据输入的 类名 查找类文件 Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3...9 定位到对应数值的书签位置 Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 Alt 快捷键 介绍 Alt + ` 显示版本控制常用操作菜单弹出层 Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多 Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 Ctrl + Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3...9 快速添加指定数值的书签 Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 Alt + Shift 快捷键 介绍 Alt + Shift + N 选择 / 添加 task Alt + Shift + F 显示添加到收藏夹弹出层 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + F 添加到收藏夹 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 移动光标所在行向下移动 Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + V 无格式黏贴 Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + Alt + C 复制参考信息 其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 F12 回到前一个工具窗口 Tab 缩进 ESC 从工具窗口进入代码文件窗口 连按两次Shift 弹出 Search Everywhere 弹出层","path":"2018/12/08/IDEA_keymap/"},{"title":"IDEA啧啧啧","text":"前些日子，被安利尝试了IntellJ IDEA这个开发工具， 对于用惯了eclipse的我来说上手还是要花点功夫的， 主要是1、开发项目的流程；2、快捷键的使用。 总体而言eclipse有的功能idea基本都有， idea还有大量的个性设置、实用插件以及对框架各种支持。 每次看到eclipse的图标还是有些愧疚） 下面是破解流程（反正我买不起。。）以及快捷键。 http://idea.lanyus.com/ 获取注册码及破解补丁的地址。。。 我用的是 IntelliJ IDEA 2018.3 ， 下载 http://idea.lanyus.com/jar/JetbrainsIdesCrack-3.4-release-enc.jar 然后放到 idea的bin目录下。 修改 bin 目录下的 idea64.exe.vmoptions 最后添加-javaagent:E:/ideaIU/bin/JetbrainsIdesCrack-3.4-release-enc.jarPS:你用几位的就改对应的文件，弄不清就2个都改。 JetbrainsIdesCrack-3.4-release-enc.jar是你刚才下载并扔到bin目录下的jar包名字。 在 hosts 文件里面添加如下配置 0.0.0.0 account.jetbrains.comPS:hosts文件路径：C:\\Windows\\System32\\drivers\\etc 基本操作结束。。打开idea，输入激活码 K71U8DBPNE-eyJsaWNlbnNlSWQiOiJLNzFVOERCUE5FIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAxOS0wNS0wNCJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTA1LTA0In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMDUtMDQifV0sImhhc2giOiI4OTA4Mjg5LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-Owt3/+LdCpedvF0eQ8635yYt0+ZLtCfIHOKzSrx5hBtbKGYRPFDrdgQAK6lJjexl2emLBcUq729K1+ukY9Js0nx1NH09l9Rw4c7k9wUksLl6RWx7Hcdcma1AHolfSp79NynSMZzQQLFohNyjD+dXfXM5GYd2OTHya0zYjTNMmAJuuRsapJMP9F1z7UTpMpLMxS/JaCWdyX6qIs+funJdPF7bjzYAQBvtbz+6SANBgN36gG1B2xHhccTn6WE8vagwwSNuM70egpahcTktoHxI7uS1JGN9gKAr6nbp+8DbFz3a2wd+XoF3nSJb/d2f/6zJR8yJF8AOyb30kwg3zf5cWw==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==","path":"2018/12/08/IDEA啧啧啧/"},{"title":"设计模式04接口隔离原则","text":"接口隔离原则Interface Segregation PrincipleClients should not be forced to depend upon interfaces that they don’t use.客户端不应该依赖它不需要的接口。The dependency of one class to another one should depend on the smallest possible interface.类间的依赖关系应该建立在最小的接口上。接口细化、不要臃肿。单一职责原则是从业务逻辑的角度，接口隔离是从数量的角度。1、接口尽量要小根据接口隔离原则拆分接口时，首先必须满足单一职责原则。2、接口要高内聚要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，风险越低，成本越低。3、定制服务4、接口设计是有限度的 接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。在实践中可以根据以下几个规则来衡量： 一个接口只服务于一个子模块或业务逻辑； 通过业务逻辑压缩接口中的public方法，接口时长去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法； 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。 了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄，环境不同，接口拆分的标准就不同。深入了解业务逻辑。 JAVA语言本来就是单继承多实现的，既然可以多实现，当初设计接口的时候按照单一职责和接口隔离职责就能规避很多风险和改动。","path":"2018/11/30/设计模式04接口隔离原则/"},{"title":"设计模式03依赖倒置原则","text":"依赖倒置原则Dependence Inversion Principle , DIPHigh level modules should not depend upon low level modules.Both should depend upon abstractions. Abstractions should not depend upon details.Details should depend upon abstractions. 高层模块不应该依赖低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象。 面向接口编程 是 OOD Object-Oriented Design 面向对象设计的精髓 public interface ICar { //是汽车就应该能跑 public void run(); } public interface IDriver { //车辆型号 public void setCar(ICar car); //是司机就应该会驾驶汽车 public void drive(); } public class BMW implements ICar{ //宝马车当然也可以开动了 public void run(){ System.out.println(&quot;宝马汽车开始运行...&quot;); } } public class Benz implements ICar{ //汽车肯定会跑 public void run(){ System.out.println(&quot;奔驰汽车开始运行...&quot;); } } public class Driver implements IDriver{ private ICar car; @Override public void setCar(ICar car){ this.car = car; } //司机的主要职责就是驾驶汽车 @Override public void drive(){ this.car.run(); } } 依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 每个类尽量都有接口或抽象类，或者抽象类和接口两者都有； 变量的表面类型尽量是接口或者是抽象类； 任何类都不应该从具体类派生； 尽量不要覆写基类的方法； 结合里氏替换原则使用。 后面会讲到桥梁模式，可以更加深入的理解依赖倒置原则。平时的开发中service层都会去实现接口去开发，比如设计一个存储功能，先抽象出接口storgeInterface，定义存文件、取文件接口，然后再根据使用场景实现它，比如localStorge、OssStorge等。就是为的是程序更健壮。","path":"2018/11/26/设计模式03依赖倒置原则/"},{"title":"设计模式02里氏替换原则","text":"里氏替换原则Liskov Substitution PrincipleIf for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T. 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。 Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.所有引用基类的地方必须能透明的使用其子类的对象。 通俗点讲，只要父类能出现的地方子类就能出现，而且替换为子类也不会产生任何错误或异常；反过来就不行，有子类的地方父类未必能适应。 4层含义： 子类必须完全实现父类的方法； 子类可以有自己的个性； 覆盖或实现父类的方法时输入参数可以被放大； 覆写或实现父类的方法时输出结果可以被缩小； 先看个问题版本 public class Father { public Collection doSomething(Map map){ System.out.println(&quot;父类被执行...&quot;); return map.values(); } } public class Son extends Father { //缩小输入参数范围 public Collection doSomething(HashMap map){ System.out.println(&quot;子类被执行...&quot;); return map.values(); } } public class Client { public static void invoker() { //有父类的地方就有子类 Father f1 = new Father(); Son s1 = new Son(); HashMap map = new HashMap(); f1.doSomething(map); //父类被执行 s1.doSomething(map); //子类被执行 } public static void main(String[] args) { invoker(); } } 注意看上面子类重载父类方法时候的入参，子类s1父类f1的doSomething方法出人传入同样的参数，输出结果却发生了变化。 public class Father { public Collection doSomething(HashMap map){ System.out.println(&quot;父类被执行...&quot;); return map.values(); } } public class Son extends Father { //放大输入参数类型 public Collection doSomething(Map map){ System.out.println(&quot;子类被执行...&quot;); return map.values(); } } public class Client { public static void invoker() { //有父类的地方就有子类 Father f1 = new Father(); Son s1 = new Son(); HashMap map = new HashMap(); f1.doSomething(map); //父类被执行 s1.doSomething(map); //父类被执行 } public static void main(String[] args) { invoker(); } } 子类s1替换父类f1输出结果还是一样。 `说白了就是子类重载父类方法时，入参的范围要大于父类的入参类型。这样在子类替换父类的时候，JAVA会根据入参不变，将方法绑定到父类方法上。 `","path":"2018/11/22/设计模式02里氏替换原则/"},{"title":"设计模式01单一职责原则","text":"讲在前面的话设计模式这个分类是我在学习《设计模式之禅–秦晓波》这本书的时候做的摘录和自己的一些理解，在平时的开发中也会学以致用，刚开始会刻意的去套用设计模式，但是慢慢的发现，设计模式知识的积累更多的是加深自己的编程思想，让代码更解耦，可复用性更高，写的代码更健壮。 单一职责原则Single Responsibility PrincipleThere should never be more than one reason for a class to change.一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责。 public interface IUserInfo { //设置用户的ID public void setUserID(String userID); //获得用户的ID public String getUserID(); //设置用户的密码 public void setPassword(String password); //获得用户的密码 public String getPassword(); //设置用户的名字 public void setUserName(String userName); //获得用户的名字 public String getUserName(); //修改用户的密码 public boolean changePassword(String oldPassword); //删除用户 public boolean deleteUser(); //用户映射 public void mapUser(); } 先看上面这个接口，既有model层面的set get操作，又有service层面的操作。如果看完这个接口引起不适的话。。那你基本已经能理解单一职责原则了； public interface IUserBiz { //修改用户的密码 public boolean changePassword(String oldPassword); //删除用户 public boolean deleteUser(); //用户映射 public void mapUser(); //增加一个组织 public void addOrg(IUserBO userBO,int orgID); //增加一个角色 public void addRole(IUserBO userBO,int roleID); } public interface IUserBO { //设置用户的ID public void setUserID(String userID); //获得用户的ID public String getUserID(); //设置用户的密码 public void setPassword(String password); //获得用户的密码 public String getPassword(); //设置用户的名字 public void setUserName(String userName); //获得用户的名字 public String getUserName(); } 优点：1、类的复杂性降低，实现什么职责都有清晰明确的定义；2、可读性提高、复杂性降低；3、可维护性提高；4、变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。 有时候这个单一职责原则是很难界定的，就比如 A给B转账 接口， 这个功能从事务的角度去看是最小颗粒度，但是实际上又包含 账户扣钱 和 账户涨钱 这2个接口； 账户金额修改这个功能又能分活期余额和定期余额。所以在实际开发中，需要做的就是根据自己的理解去把握这个单一职责的度，心里要有这个概念。","path":"2018/11/21/设计模式01单一职责原则/"},{"title":"hexo-github搭建博客3-问题整理","text":"持续更新： hexo官方文档2d插件1.安装这个live2d插件检查package.json里有没有 hexo-heloper-live2d 依赖，有的话先卸载了，然后重新安装一下。12npm uninstall hexo-helper-live2d npm install --save hexo-helper-live2d 2.下载动画model 点这里 https://github.com/xiazeyu/live2d-widget-models.git3.将packages里面所有的模版放到你博客的node_modules目录里4.配置博客的配置文件，_config.yml 123456789101112131415161718192021# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 display: superSample: 2 width: 150 height: 300 position: right hOffset: 0 vOffset: -20 mobile: show: true scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 载入图片1 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true，之后生成的博文则会在同路径下增加一个同名文件夹，用来放资源。 2 执行 npm install hexo-asset-image –save 3 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](xxxx/图片名.jpg) CNAME 问题gitpage里面可以设置自己的域名访问，首先域名配置CNAME = 自己的 gitpage，然后在仓库设置 custom domain ； 每次 hexo deploy 之后，custom domain 都会被重置为空，在hexo的source目录下 新建一个 CANME 文件，在里面写上你自己的域名，之后再提交就不会有问题啦！！ 搜索我用的主题搜索框的设计样式参考了ppoffice的设计样式,只要进行输入即可进行对应的搜索, 此功能需要在您的Hexo站点上进行hexo-generator-json-content的安装和设置npm install hexo-generator-json-content --save然后在您的Hexo站点的_config.yml(非主题的_config.yml)上进行对应的设置:1234567891011jsonContent: pages: title: true text: true path: true preview: true posts: title: true text: true path: true preview: true tags和categories页面默认是没有 categories 和 tags 的；12hexo new page &quot;tags&quot; hexo new page &quot;categories&quot; 编辑source下的tags和categories目录下的md文件123456type: &quot;tags&quot;layout: &quot;tags&quot;type: &quot;categories&quot;layout: &quot;categories&quot;","path":"2018/11/17/hexo-github搭建博客3-问题整理/"},{"title":"hexo-github搭建博客2-语法入门","text":"本文内容为转载：https://blog.csdn.net/zhuzhuyule/article/details/58347687转载同时自己练习一下 补充一点内容 Markdown 是一种轻量级的 「标记语言」，优点在于： 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 并且具有以下特点： 自动生成目录 代码块高亮 引用展示 表格插入 图片插入 强调显示 列表显示 自动URL链接 Hexo下使用的MarkDown为Github的GFM，风格很漂亮，简洁美观大方。但是GFM 的MarkDown语法和标准 的MarkDown稍有不同，使用过程中需要注意一些。 首先你要知道转义字符 转义字符常用对照表 或者用 \\ 转义 语法简明概述分段 两个回车换行 两个空格 + 回车标题 # ~ ######，#号的个数表示几级标题，即表示一级标题到六级标题强调 **文字** ，\\ __文字__ ， _文字_ ， *文字* ， 文字引用 &gt; 注意后面紧跟个空格表格 - 和 | 分割行和列 ， : 控制对其方式代码块 四个空格 开头或， 使用``` 代码内容```链接 [文字](链接地址)图片 ![图片说明](图片地址) ，地址可以是本地路劲，也可以是网络地址列表 * ， + ， - ， 1. ，选其中之一，注意后面紧跟个空格 标题# 欢迎使用Markdown编辑器写博客 //一级标题 对应 &#60;h1&#62; &#60;/h1\\&#62;## 标题输入 //二级标题 对应 &#60;h2&#62; &#60;/h2&#62;### 三级标题 //三级标题 对应 &#60;h3&#62; &#60;/h3&#62;#### 四级标题 //四级标题 对应 &#60;h4&#62; &#60;/h4&#62;##### 五级标题 //五级标题 对应 &#60;h5&#62; &#60;/h5&#62;###### 六级标题 //六级标题 对应 &#60;h6&#62; &#60;/h6&#62;####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 内容强调加粗、斜体字体 **加粗** 显示字体 *斜体* 显示字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 字体 __加粗__ 显示字体 _斜体_ 显示字体 ___加粗并斜体___ 显示组合 *__加粗并斜体__* 显示 字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示组合 加粗并斜体 显示 删除线这样来 ~~删除一段文本~~ 这样来 删除一段文本 高亮使用`来强调字符 //想打出 ` (反引号)需要转义的，加&#60;code&#62;&#60;/code&#62;标签强调比如`突出背景色`来显示强调效果上面的效果其实是这么实现的 `` `突出背景色` `` 引用显示引用过程中任然支持Markdown语法！ 标准使用> 每行开始都使用 ‘>‘；> 引用开始；> 引用换行；> 引用结束。 > 还在引用中！ 两个回车结束引用！ 每行开始都使用 ‘&gt;’；引用开始；引用换行；引用结束。 还在引用中！ 两个回车结束引用！ 省略使用> 仅第一行加引用；引用开始；引用换行；引用结束； 两个回车结束引用,不在引用范围内了！ 仅第一行加引用；引用开始；引用换行；引用结束； 两个回车结束引用,不在引用范围内了！ 嵌套使用> 动物>> 水生动物>> 陆生动物>>> 猴子>>> 人>>>> 程序猿>>>> 攻城狮>>产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记 >> 两栖类动物>>> 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //没有空行间隔，忽略降级引用标记射鸡虱 //没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 表格表格语法：列1 | 列2 | 列3----- | ---| ----第1行 | 12 | 13第2行 | 22 | 23第3行 | 32 | 33 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 可以使用冒号来定义对齐方式：| 左对齐 | 右对齐 | 居中 || :——– | ——-:| :–: || Computer | 5000 元 | 1台 || Phone | 1999 元 | 1部 | 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 代码块代码块语法遵循标准 markdown 代码，使用```开始，```结束 例如： ```Python#!/usr/bin/env python# -- coding: utf-8 --print ‘Hello World! ``` 123#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World! 如何在代码块中打出 ``` 实际上是使用 4个` 包含 3个` 就可以了，想表示更多，最外层+1就好了。 ```` ``` ``` ```` 链接插入123[首页](http://zhuzhuyule.xyz)[我的信息](/about/)[纪念册](https://love.zhuzhuyule.xyz/) 首页 我的信息 纪念册 图片插入 12345 ![图片alt](图片地址 &quot;图片title&quot;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 ![我的头像](http://zhuzhuyule.xyz/images/avatar.png) ![我的头像](/images/avatar.png) 列表无序列表 * *列表展示 * *列表展示 * *列表展示 + +列表展示 + +列表展示 + +列表展示 - -列表展示 - -列表展示 - -列表展示 *列表展示 *列表展示 *列表展示 +列表展示 +列表展示 +列表展示 -列表展示 -列表展示 -列表展示 有序列表 数字加点 二级序列 3个空格 这种方式不用手动设置序号，自动生成列表序列 我是一级序列 我是一级序列 我是一级序列 我是二级序列 我是二级序列 我是二级序列 我是一级序列 我是一级序列 我是二级序列 我是二级序列 我是二级序列 我是三级序列 #链接自动检测 [超链接名](超链接地址 “超链接title”)title可加可不加 首页:http://zhuzhuyule.xyz 我的信息:http://zhuzhuyule.xyz/about/ 纪念册:https://love.zhuzhuyule.xyz/ 补充分割线 三个或者三个以上的 - 或者 * 都可以。 流程图","path":"2018/11/15/hexo-github搭建博客2-语法入门/"},{"title":"hexo-github搭建博客1-小试牛刀","text":"一、准备环境：1、安装Node.js环境；2、安装Git环境，主要是用于直接同步生成的博客；3、通过npm安装Hexo12输入npm install hexo -g，开始安装Hexo输入hexo -v，检查hexo是否安装成功 二、初始化blog：1、新建blog文件夹2、通过Hexo初始化blog12345进入blog文件夹输入hexo init，初始化该文件夹输入npm install，安装所需要的组件输入hexo g，生成blog发布文件输入hexo s，开启服务器 三、关联Githb并推送1、创建Github账号2、创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.iogithub repositories Settings 12repositories name : sumnear.github.ioCustom domain 设置自己的域名 sumnear.top 3、将本地Hexo博客推送到GithubPages 3.1 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可：1$ npm install hexo-deployer-git --save 3.2 修改_config.yml（在站点目录下）。文件末尾修改为：1234deploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 3.3 设置Git的user name和email12git config --global user.name &quot;sumnear&quot;git config --global user.email &quot;402347012@qq.com&quot; 3.4 hexo把blog内容推送到github上1hexo d","path":"2018/11/14/hexo-github搭建博客1-小试牛刀/"}]}